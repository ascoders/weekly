这次是前端精读期刊与大家第一次正式碰面，我们每周会精读并分析若干篇精品好文，试图讨论出结论性观点。没错，我们试图通过观点的碰撞，争做无主观精品好文的意见领袖。

我是这一期的主持人 ——

<img src="https://avatars2.githubusercontent.com/u/7970947?v=3&s=460" alt="arcthur" width="100" height="100">

[黄子毅](https://github.com/ascoders)

本期精读的文章是：[evolutionOfJsModularity](https://github.com/myshov/history-of-javascript/tree/master/4_evolution_of_js_modularity)。

懒得看文章？没关系，稍后会附上文章内容概述，同时，更希望能通过阅读这一期的精读，穿插着深入阅读原文。

# 1 引言

![module](assets/1/cube.jpeg)

> 如今，Javascript 模块化规范非常方便、自然，但这个新规范仅执行了2年，就在 4 年前，js 的模块化还停留在运行时支持，10 年前，通过后端模版定义、注释定义模块依赖。对经历过来的人来说，历史的模块化方式还停留在脑海中，反而新上手的同学会更快接受现代的模块化规范。

但为什么要了解 Javascript 模块化发展的历史呢？因为凡事都有两面性，了解 Javascript 模块化规范，有利于我们思考出更好的模块化方案，纵观历史，从 1999 年开始，模块化方案最多维持两年，就出现了新的替代方案，比原有的模块化更清晰、强壮，我们不能被现代模块化方式限制住思维，因为现在的 ES2015 模块化方案距离发布也仅仅过了两年。

# 2 内容概要

### 直接定义依赖 (1999)

由于当时 js 文件非常简单，模块化方式非常简单粗暴 —— 通过全局方法定义、引用模块。

这种定义方式与现在的 commonjs 非常神似，区别是 commonjs 以文件作为模块，而这种方法可以在任何文件中定义模块，模块不与文件关联。

其实现在 Typescript 定义 namespace 的方式，和这种方法特别的像，因为我们可以在一个文件定义多个 `namespace`:

```typescript
declare namespace app;
declare namespace user;
```

但这种突兀的变量定义方式不利于项目维护，还需要手动维护模块定义，可用，但不优雅。

### 闭包模块化模式 (2003)

用闭包方式解决了变量污染问题，闭包内返回模块对象，只需对外暴露一个全局变量。

但影响一个也是影响，多了还是容易乱套，这种方式没有解决文件引用顺序问题，不同加载顺序可能出现全局变量未赋值的情况（定义倒是提前了，但还是会报错）。

### 模版依赖定义 (2006)

这时候开始流行后端模版语法，通过后端语法聚合 js 文件，从而实现依赖加载，说实话，现在 go 语言等模版语法也很流行这种方式，写后端代码的时候不觉得，回头看看，还是挂在可维护性上。

### 注释依赖定义 (2006)

几乎和模版依赖定义同时出现，与 1999 年方案不同的，不仅仅是模块定义方式，而是终于以文件为单位定义模块了，通过 [lazyjs](https://github.com/bevacqua/lazyjs) 加载文件，同时读取文件注释，继续递归加载剩下的文件。

这简直和最新标准 `<script type=module>` 如出一辙，如今仅仅将这个思想标准化了，将注释定义依赖替换成了 `import` `export` 关键词罢了。

挺支持这种方式的，连打包都不需要了，现在终于得到标准的支持，非常激动人心。

### 外部依赖定义 (2007)

这种定义方式在 cocos2d-js 开发中普遍使用，其核心思想是将依赖抽出单独文件定义，这种方式不利于项目管理，毕竟依赖抽到代码之外，我是不是得两头找呢？所以才有通过 webwpack 打包为一个文件的方式暴力替换为 commonjs 的方式出现。

### Sandbox模式 (2009)

这种模块化方式很简单，暴力，将所有模块塞到一个 `sanbox` 变量中，硬伤是无法解决明明冲突问题，毕竟都塞到一个 `sandbox` 对象里，而 `Sandbox` 对象也需要定义在全局，存在被覆盖的风险。模块化需要保证全局变量尽量干净，目前为止的模块化方案都没有很好的做到这一点。

现在 `webpack` `vendor` 加载方式很像 `sanbox` 模式，在 `cdn` 分发模块的时候，基础库使用 `sanbox` 思想是比较常用的。

### 依赖注入 (2009)

就是大家熟知的 angular1.0，依赖注入的思想现在已广泛运用在 react、vue 等流行框架中。但依赖注入和解决模块化问题还差得远。

### CommonJS (2009)

真正解决模块化问题，从 node 端逐渐发力到前端，前端需要使用构建工具模拟。

### Amd (2009)

都是同一时期的产物，这个方案主要解决前端动态加载依赖，相比 commonJs，体积更小，按需加载。

### Umd (2011)

兼容了 CommonJS 与 Amd，其核心思想是，如果在 commonjs 环境（存在 `module.exports`，不存在 `define`），将函数执行结果交给 `module.exports` 实现 Commonjs，否则用 Amd 环境的 `define`，实现 Amd。

### Labeled Modules (2012)

和 Commonjs 很像了，没什么硬伤，但生不逢时，碰上 Commonjs 与 Amd，那只有被人遗忘的份了。

### YModules (2013)

既然都出了 Commonjs Amd，文章还列出了此方案，一定有其独到之处。

其核心思想在于使用 `provide` 取代 `return`，可以控制模块结束时机，处理异步结果；拿到第二个参数 `module`，修改其他模块的定义（虽然很有拓展性，但用在项目里是个搅屎棍）。

### ES2015 Modules (2015)

就是我们现在的模块化方案，还没有被浏览器实现，大部分项目已通过 `babel` 或 `typescript` 提前体验。

# 3 精读

<img src="https://avatars2.githubusercontent.com/u/322331?v=3&s=88" alt="arcthur" width="100" height="100">

[arcthur](https://github.com/arcthur)

这篇文章所提供的模块化历史的方案都是逻辑模块化，从 CommonJS 方案开始前端把服务端的解决方案搬过来之后，算是看到标准物理与逻辑统一的模块化。但之后前端工程不得不引入模块化构建这一步。正是这一步给前端开发无疑带来了诸多的不便，尤其是现在我们开发过程中经常为了优化这个工具带了很多额外的成本。

再回到 JS 模块化这个主题，开头也说到是为了构建 scope，实则提供了业务规范标准的输入输出的方式。但文章中的 JS 的模块化还不等于前端工程的模块化，Web 界面是由 HTML、CSS 和 JS 三种语言实现，不论是 CommonJS 还是 AMD 包括之后的方案都无法解决 CSS 与 HTML 模块化的问题。

对于 CSS 本身它就是 global scope，因此开发样式可以说是喜忧参半。近几年也涌现把 HTML、CSS 和 JS 合并作模块化的方案，其中 react/css-modules 和 vue 都为人熟知。当然，这一点还是非常依赖于 webpack/rollup 等构建工具，让我们意识到在 browser 端还有很多本质的问题需要推进。

幸运的是，模块化构建将来一定不再需要。随着 HTTP/2 流行起来，请求和响应可以并行，一次连接允许多个请求，对于前端来说宣告不再需要在开发和上线时再做编译这个动作。

从 CommonJS 之前其实都只是封装，并没有一套模块化规范，这个就有些像类与包的概念。我在10年左右用的最多的还是 YUI2，YUI2 是用 namespace 来做模块化的，但有很多问题没有解决，比如多版本共存，因此后来 YUI3 出来了。

```javascript
YUI().use('node', 'event', function (Y) {
    // The Node and Event modules are loaded and ready to use.
    // Your code goes here!
});
```

YUI3 的 sandbox 像极了差不多同时出现的 AMD 规范，但早期 yahoo 在前端圈的影响力还是很大的，而 requirejs 到 2011 年才诞生，因此圈子不是用着 YUI 要不就自己封装一套 sandbox，内部使用 jQuery。

为什么模块化方案这么晚才成型，我猜是早期应用的复杂度都在后端，前端都是非常简单逻辑。后来 Ajax 火了之后，web app 概念的开始流行，前端的复杂度也呈指数级上涨，到今天几乎和后端接近一个量级。

工程发展到一定阶段，要出现的必然会出现。

---

<img src="https://avatars1.githubusercontent.com/u/7970947?v=3&s=88" alt="黄子毅" width="100" height="100">

[黄子毅](https://github.com/ascoders)

正如 @arcthur 所说，原生支持的模块化，解决 html 与 css 模块化问题正是以后的方向。

对于 css 模块化，目前不依赖预编译的方式是 `styled-component`，通过 js 动态创建 class。而目前 css 也引入了[与 js 通信的机制 与 原生变量支持](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_variables)。未来 css 模块化也很可能是运行时的，所以目前比较看好 `styled-component` 的方向。

对于 html 模块化，小尤最近爆出与 chrome 小组调研 html Modules，如果 html 得到了浏览器，编辑器的模块化支持，未来可能会取代 jsx 成为最强大的模块化、模板语言。

对于 js 模块化，最近出现的 <script type="module"> 方式，虽然还没有得到浏览器原生支持，但也是我比较看好的未来趋势，这样就连 webpack 的拆包都不需要了，直接把源代码传到服务器，配合 http2.0 完美抛开预编译的枷锁。

上述三中方案都不依赖预编译，分别实现了 html、css、js 模块化，相信这就是未来。

---

<img src="https://avatars3.githubusercontent.com/u/1928018?v=3&s=88" alt="javie007" width="100" height="100">

[javie007](https://github.com/javie007)

angular 不只是模块的依赖，还涉及 DI 的使用；一个语言设计之初没考虑到模块化，坑了整整一代人；

这几年 TC39 对语言终于重视起来了，慢慢有动作了，但针对模块加载器这方面依然慢的要死，很难想象这样的JS是世界上最流行的语言；

node不知道何时才能支持ES2015 Modules，node程序员伤不起；模块化这部分工作本来不应该让程序员的时间花在这上面；

---

<img src="https://avatars3.githubusercontent.com/u/948896?v=3&s=88" alt="Cam Song" width="100" height="100">

[Cam Song](https://github.com/camsong)

几年前，模块化几乎是每个流行库必造的轮子（YUI、Dojo、Angular），大牛们自己爽的同时其实造成了社区的分裂，很难积累。有了 ES2015 Modules 之后，JS 开发者终于可以像 Java 开始者十年前一样使用一致的方式愉快的互相引用模块。不过 ES2015 Modules 也只是解决了开发的问题，由于浏览器的特殊性，还是要经过繁琐打包的过程，等 Import，Export 和 HTTP 2.0 被主流浏览器支持，那时候才是彻底的模块化。JS 进化很快，现在 CSS 的问题就比较突出了，CSS 虽然有 variables 等，但一直都没有添加模块和逻辑表现能力的苗头，再不进化可能就被 JS 取代了。

---

<img src="https://avatars3.githubusercontent.com/u/1336484?v=3&s=88" alt="Sen Yang" width="100" height="100">

[Sen Yang](https://github.com/jasonslyvia)

看到大家的评论里基本都提到了 HTTP/2，对这项技术解决前端模块化及资源打包等工程问题抱有非常大的期待。很多人也认为 HTTP/2 普及后，基本就没有 Webpack 什么事情了。

不过 Webpack 作者 @sokra 在他的文章 [webpack & HTTP/2](https://medium.com/webpack/webpack-http-2-7083ec3f3ce6#.zdo4juvgo) 里提到了一个新的 Webpack 插件 `AggressiveSplittingPlugin`。简单的说，这款插件就是为了充分利用 HTTP/2 的文件缓存能力，将你的业务代码自动拆分成若干个数十 KB 的小文件。后续若其中任意一个文件发生变化，可以保证其他的小 chunck 不需要重新下载。

可见，即使不断的有新技术出现，也依然需要配套的工具来将前端工程问题解决方案推向极致。

---

<img src="https://avatars0.githubusercontent.com/u/9314735?v=3&s=88" alt="爱but的苍蝇" width="100" height="100">

[爱but的苍蝇](https://github.com/BlackGanglion)

首先抛开 JavaScript 来看为何要模块化，模块化从软件工程的角度讲是为了让软件具备良好的可维护性与可复用性，降低软件开发成本的同时让软件在业务层面具有灵活性。正如 @arcthur 所说，JavaScript 模块化的发展历程与前端复杂度提升是密切相关的，从纯后端渲染的视图模版到前后端分离的单页应用，对模块化要求越来越高。模块化发展始终围绕两大绊脚石，**JavaScript 本身缺陷** 与 **浏览器环境**，随着 ES2015 Modules、HTTP/2等等的真正落地，相信 JavaScript 模块化方案会走向标准与统一。

最后来点补充材料，供大家参考：
[JavaScript 模块化七日谈](https://huangxuan.me/2015/07/09/js-module-7day/)
[JavaScript模块化编程简史（2009-2016）](https://yuguo.us/weblog/javascript-module-development-history/)

# 总结

未来前端复杂度不断增加已成定论，随着后端成熟，自然会将焦点转移到前端领域，而且服务化、用户体验越来越重要，前端体验早不是当初能看就行，任何网页的异常、视觉的差异，或文案的模糊，都会导致用户流失，支付中断。前端对公司营收的影响，渐渐与后端服务宕机同等严重，所以前端会越来越重，异常监控，性能检测，工具链，可视化等等都是这几年大家逐渐重视起来的。

我们早已不能将 javascript 早期玩具性质的模块化方案用于现代越来越重要的系统中，前端界必然出现同等重量级的模块化管理方案，感谢 TC39 制定的 ES2015 模块化规范，我们已经离不开它，哪怕所有人必须使用 babel。

话说回来，标准推进的太慢，我们还是把编译工具当作常态，抱着哪怕支持了 ES2015 所有特性，babel 依然还有用的心态，将预编译进行到底。一句话，模块化仍在路上。js 模块化的矛头已经对准了 css 与 html，这两位元老也该向前卫的 js 学习学习了。

未来 css、html 的模块化会自立门户，还是赋予 js 更强的能力，让两者的模块化依附于 js 的能力呢？目前 html 有自立门户的苗头（htmlModules），而 css 迟迟没有改变，社区出现的 `styled-component` 已经用 js 将 css 模块化得很好了，最新 css 规范也支持了与 js 的变量通信，难道希望依附于 js 吗？这里希望得到大家更广泛的讨论。

我也认同，毕竟压缩、混淆、md5、或者利用 [nonce](https://www.thepolyglotdeveloper.com/2015/03/create-a-random-nonce-string-using-javascript/) 属性对 script 标签加密，都离不开本地构建工具。

据说 http2 的优化中，有个最佳文件大小与数量的比例，那么还是脱离不了构建工具，前端未来会越来越复杂，同时也越来越美好。

至此，对于 javascript 模块化讨论已接近尾声，对其优缺点也基本达成了一致。前端复杂度不断提高，促使着模块化的改进，代理（浏览器、node） 的支持程度，与前端特殊性（流量、缓存）可能前端永远也离不开构建工具，新的标准会让这些工作做的更好，同时取代、增强部分特征，前端的未来是更加美好的，复杂度也更高。